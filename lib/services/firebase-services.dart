import 'dart:io';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:file_picker/file_picker.dart';
import 'package:firebase_storage/firebase_storage.dart';
import '../models/note_model.dart';
import '../models/user_model.dart';

class FirestoreServices {
  //attributes
  static final _usersCollection =
      FirebaseFirestore.instance.collection('users');
  static final _notesCollection =
      FirebaseFirestore.instance.collection('notes');
  static final _categoriesCollection =
      FirebaseFirestore.instance.collection('categories');

//**********************     users             ********************** */

//creates a user , or if the user already exists, update their information
//parameters : user : a user that you create after succesfully collecting the data you need in the update profile screen
  static Future createOrUpdateUser(User user) async {
    //this generates a new empty doc in users collection and gives it the user id to set as the document id
    final newUserDoc = _usersCollection.doc(user.uID); //this is a doc reference
    await newUserDoc.set(user.toFirestore());
  }

  //if this function finds the user your are looking for it returns it, else it will return null
  /*parameters :
  uID : this is the unique id generated by firebase auth once the user signs up for the first time
  you can fetch it anywhere in the project with 
  FirebaseAuth.instance.currentUser!.uid
  */
  static Future<User?> fetchUser(String? uID) async {
    final userDoc =
        await _usersCollection.doc(uID).get(); //this is a doc snapshot
    if (userDoc.exists) {
      return User.fromFirestore(userDoc);
    } else {
      return null;
    }
  }

  //this function fetches multiples users from the database
  //by default all returend users are sorted based on their total rating
  //you choose how many users you want to fetch with the parameter 'number'
  //you can optionally also pass a second parameter 'lastUser'
  /*normally if you want an infinitely scrolling list (like a user leaderboard) where the application keeps
    fetching more users to display as we scroll down the list , you don't want the db to fetch every single user stored at once
    because this would be terrible for performace*/
  //instead if you pass the lastUser parameter, the db will start fetching users after that user
  //I.E lets say you fetched users 1 2 3 from the db
  //now you want to fetch more users but don't want to fetch 1 2 3 again
  //pass User number 3 as a paramter to this function and it will start fetching from user 4
  static Future<List<User?>> fetchAllUsersByrating(int number,
      {User? lastUser}) async {
    final userDocs;
    List<User?> userslist = [];
    if (lastUser != null) {
      final lastUserDoc = await _usersCollection.doc(lastUser.uID).get();
      if (lastUserDoc.exists) {
        userDocs = await _usersCollection
            .orderBy('totalRating')
            .startAfterDocument(lastUserDoc)
            .limit(number)
            .get();
      } else {
        userDocs =
            await _usersCollection.orderBy('totalRating').limit(number).get();
      }
    } else {
      userDocs =
          await _usersCollection.orderBy('totalRating').limit(number).get();
    }
    for (final doc in userDocs.docs) {
      userslist.add(User.fromFirestore(doc));
    }
    return userslist;
  }

  //******************************************************************* */

  //**********************        notes ******************************** */
  //creates a note on our db and returns its randomly generated uid incase you want to fetch it again and do sth with it
  static Future<String?> createNote(Note note) async {
    final newNoteDoc = _notesCollection.doc();
    note.uID = newNoteDoc.id;
    await newNoteDoc.set(note.toFirestore());
    return note.uID;
  }

  //updates an existing note , we don't check if this note already exists because how on earth would the user
  //trigger a note editing screen without first selecting an existing note
  static Future updateExistingNote(Note note) async {
    final noteDoc = _notesCollection.doc(note.uID);
    await noteDoc.set(note.toFirestore());
  }

  //fetches a note by its uID , if the note doesn't exist , returns null
  static Future<Note?> fetchNote(String? noteUID) async {
    final noteDoc =
        await _notesCollection.doc(noteUID).get(); //this is a doc snapshot
    if (noteDoc.exists) {
      return Note.fromFirestore(noteDoc);
    } else {
      return null;
    }
  }
}

class StorageServices {
  //attributes
  static final _storageRef = FirebaseStorage.instance.ref();
  static final _usersBucketRef = FirebaseStorage.instance.ref().child('users');
  static final _notesBucketRef = FirebaseStorage.instance.ref().child('notes');

  //upload a user profile photo , returns a url with the photo after it has been uploaded so you can load it
  static Future<String> uploadUserPhoto(User user) async {
    FilePickerResult? result =
        await FilePicker.platform.pickFiles(type: FileType.image);

    if (result != null) {
      File file = File(result.files.first.path!);
      String fileName = result.files.first.name;

      //upload file
      await _usersBucketRef.child(user.uID!).child(fileName).putFile(file);
      return _usersBucketRef.child(user.uID!).child(fileName).getDownloadURL();
    } else {
      return "Cancelled";
    }
  }
}
