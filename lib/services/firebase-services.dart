import 'dart:io';
import 'package:collection/collection.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:file_picker/file_picker.dart';
import 'package:firebase_storage/firebase_storage.dart';

import 'package:flutter/material.dart';
import '../models/note_model.dart';
import '../models/user_model.dart';

class FirestoreServices {
  //attributes
  static final _usersCollection =
      FirebaseFirestore.instance.collection('users');
  static final _notesCollection =
      FirebaseFirestore.instance.collection('notes');
  static final _categoriesDoc =
      FirebaseFirestore.instance.collection('search').doc('categories');

//**********************     users             ********************** */

//creates a user , or if the user already exists, update their information
//parameters : user : a user that you create after succesfully collecting the data you need in the update profile screen
  static Future createUser(User user) async {
    //this generates a new empty doc in users collection and gives it the user id to set as the document id
    final newUserDoc = _usersCollection.doc(user.uID); //this is a doc reference
    await newUserDoc.set(user.toFirestore());
  }

  static Future updateUser(User user) async {
    //this generates a new empty doc in users collection and gives it the user id to set as the document id
    final newUserDoc = _usersCollection.doc(user.uID); //this is a doc reference
    await newUserDoc.set(user.toFirestore());
    //add check here somehow
  }

  //if this function finds the user your are looking for it returns it, else it will return null
  /*parameters :
  uID : this is the unique id generated by firebase auth once the user signs up for the first time
  you can fetch it anywhere in the project with 
  FirebaseAuth.instance.currentUser!.uid
  */
  static Future<User?> fetchUser(String uID) async {
    final userDoc =
        await _usersCollection.doc(uID).get(); //this is a doc snapshot
    if (userDoc.exists) {
      return User.fromFirestore(userDoc);
    } else {
      return null;
    }
  }

  //this function fetches multiples users from the database
  //by default all returend users are sorted based on their total rating
  //you choose how many users you want to fetch with the parameter 'number'
  //you can optionally also pass a second parameter 'lastUser'
  /*normally if you want an infinitely scrolling list (like a user leaderboard) where the application keeps
    fetching more users to display as we scroll down the list , you don't want the db to fetch every single user stored at once
    because this would be terrible for performace*/
  //instead if you pass the lastUser parameter, the db will start fetching users after that user
  //I.E lets say you fetched users 1 2 3 from the db
  //now you want to fetch more users but don't want to fetch 1 2 3 again
  //pass User number 3 as a paramter to this function and it will start fetching from user 4
  static Future<List<User>> fetchAllUsersByrating(int number,
      {User? lastUser}) async {
    final userDocs;
    List<User> userslist = [];
    if (lastUser != null) {
      final lastUserDoc = await _usersCollection.doc(lastUser.uID).get();
      if (lastUserDoc.exists) {
        userDocs = await _usersCollection
            .orderBy('totalRating', descending: true)
            .startAfterDocument(lastUserDoc)
            .limit(number)
            .get();
      } else {
        userDocs = await _usersCollection
            .orderBy('totalRating', descending: true)
            .limit(number)
            .get();
      }
    } else {
      userDocs = await _usersCollection
          .orderBy('totalRating', descending: true)
          .limit(number)
          .get();
    }
    for (final doc in userDocs.docs) {
      userslist.add(User.fromFirestore(doc));
    }
    return userslist;
  }

  //******************************************************************* */

  //*********************categories */

  static Future<List<String>?> fetchCategories() async {
    final catDoc = await _categoriesDoc.get();
    final cats = List<String>.from(catDoc.data()?['allCategories'] as List);
    return cats;
  }

  //**********************        notes ******************************** */
  //get
  static String generateNoteUID() {
    final newNoteDoc = _notesCollection.doc();
    return newNoteDoc.id;
  }

  static Future createNote(Note note) async {
    final newNoteDoc = _notesCollection.doc(note.uID);
    await newNoteDoc.set(note.toFirestore());
  }

  //updates an existing note , we don't check if this note already exists because how on earth would the user
  //trigger a note editing screen without first selecting an existing note
  static Future updateExistingNote(Note note) async {
    final noteDoc = _notesCollection.doc(note.uID);
    await noteDoc.set(note.toFirestore());
  }

  static interactWithNote(Note note, String targetUserUID,
      {int? ratingModification,
      Map<String, dynamic>? comment,
      bool removeExistingComment = false,
      String? commenterIDToRemoveFrom,
      int? downloadModification}) async {
    User? targetUser = await fetchUser(targetUserUID);
    if (targetUser == null) return;
    if (ratingModification != null) {
      note.rating += ratingModification;
      targetUser.totalRating += ratingModification;
      await updateUser(targetUser);
    }

    if (comment != null && !removeExistingComment) {
      //this is a new comment
      if (note.comments.firstWhere(
              (element) => element['commenterUid'] == comment['commenterUid'],
              orElse: () => "") ==
          "") {
        note.comments.add(comment);
      } else {
        note.comments.firstWhere((element) =>
                element['commenterUid'] == comment['commenterUid'])['comment'] =
            comment['comment'];
      }
    }
    if (removeExistingComment && commenterIDToRemoveFrom != null) {
      note.comments.remove(note.comments.firstWhere(
          (element) => element['commenterUid'] == commenterIDToRemoveFrom));
    }
    if (downloadModification != null) {
      note.downloadCount += downloadModification;
      targetUser.downloadCount += downloadModification;
      await updateUser(targetUser);
    }

    await updateExistingNote(note);
  }

  //fetches a note by its uID , if the note doesn't exist , returns null
  static Future<Note?> fetchNote(String? noteUID) async {
    final noteDoc =
        await _notesCollection.doc(noteUID).get(); //this is a doc snapshot
    if (noteDoc.exists) {
      return Note.fromFirestore(noteDoc);
    } else {
      return null;
    }
  }

  static Future<List<Note>> fetchAllNotesUnderCategoryByrating(
      int number, String category,
      {Note? lastNote}) async {
    if (category == "") category = 'General';
    final noteDocs;
    List<Note> notelist = [];
    if (lastNote != null) {
      final lastNoteDoc = await _notesCollection.doc(lastNote.uID).get();
      if (lastNoteDoc.exists) {
        noteDocs = await _notesCollection
            .where('category', isEqualTo: category)
            .orderBy('rating', descending: true)
            .startAfterDocument(lastNoteDoc)
            .limit(number)
            .get();
      } else {
        noteDocs = await _notesCollection
            .where('category', isEqualTo: category)
            .orderBy('rating', descending: true)
            .limit(number)
            .get();
      }
    } else {
      noteDocs = await _notesCollection
          .where('category', isEqualTo: category)
          .orderBy('rating', descending: true)
          .limit(number)
          .get();
    }
    for (final doc in noteDocs.docs) {
      notelist.add(Note.fromFirestore(doc));
    }
    return notelist;
  }

  static Future<List<Note>> fetchAllNotesInList(
    List<String> references,
  ) async {
    QuerySnapshot<Map<String, dynamic>> noteDocs;
    List<Note> notelist = [];
    var referencesChunks = [];
    if (references.isEmpty) return [];

    referencesChunks = references.slices(10).toList();

    for (var chunk in referencesChunks) {
      noteDocs = await _notesCollection.where('uID', whereIn: chunk).get();
      for (final doc in noteDocs.docs) {
        notelist.add(Note.fromFirestore(doc));
      }
    }
    return notelist;
  }

  static Future<List<Note>> searchForNoteUnderCategoryByrating(
      String items, int number, String category,
      {Note? lastNote}) async {
    if (items == "") return [];
    final noteDocs;
    List<Note> notelist = [];
    if (lastNote != null) {
      final lastNoteDoc = await _notesCollection.doc(lastNote.uID).get();
      if (lastNoteDoc.exists) {
        noteDocs = await _notesCollection
            .where('category', isEqualTo: category)
            .where('nameParts', arrayContains: items)
            .orderBy('rating', descending: true)
            .startAfterDocument(lastNoteDoc)
            .limit(number)
            .get();
      } else {
        noteDocs = await _notesCollection
            .where('category', isEqualTo: category)
            .where('nameParts', arrayContains: items)
            .orderBy('rating', descending: true)
            .limit(number)
            .get();
      }
    } else {
      noteDocs = await _notesCollection
          .where('category', isEqualTo: category)
          .where('nameParts', arrayContains: items)
          .orderBy('rating', descending: true)
          .limit(number)
          .get();
    }
    for (final doc in noteDocs.docs) {
      notelist.add(Note.fromFirestore(doc));
    }
    return notelist;
  }
}

class StorageServices {
  //attributes
  static final storage = FirebaseStorage.instance;

  static final _usersBucketRef = FirebaseStorage.instance.ref().child('users');
  static final _notesBucketRef = FirebaseStorage.instance.ref().child('notes');

  //upload a file , if its a user photo then pass userUID , if its a note file or note cover pass the note id
  static Future<String?> uploadToStorage(BuildContext context, String iD,
      FilePickerResult? result, int operationKind) async {
    if (result == null) return null;
    File file = File(result.files.first.path!);
    bool status = true;
    String? res;
    //upload file
    try {
      if (operationKind == 0) {
        //uploading user cover photo
        final task =
            _usersBucketRef.child(iD).child('ProfilePic').putFile(file);
        task.snapshotEvents.listen((event) async {
          if (event.state == TaskState.canceled ||
              event.state == TaskState.error) status = false;
          if (event.state == TaskState.running) {
            ScaffoldMessenger.of(context).removeCurrentSnackBar();
            ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                content: Text(
                    '${event.bytesTransferred / await file.length()} % completed')));
          }
        });
        final value = await task.whenComplete(() => null);
        if (value.state == TaskState.success && status) {
          res = await _usersBucketRef
              .child(iD)
              .child('ProfilePic')
              .getDownloadURL();
        }
        ;
      } else if (operationKind == 1) {
        //uploading note cover
        final task = _notesBucketRef.child(iD).child('NotePic').putFile(file);
        task.snapshotEvents.listen((event) async {
          if (event.state == TaskState.canceled ||
              event.state == TaskState.error) status = false;
          if (event.state == TaskState.running) {
            ScaffoldMessenger.of(context).removeCurrentSnackBar();
            ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                content: Text(
                    '${event.bytesTransferred / await file.length()} % completed')));
          }
        });
        final value = await task.whenComplete(() => null);
        if (value.state == TaskState.success && status) {
          res =
              await _notesBucketRef.child(iD).child('NotePic').getDownloadURL();
        }
        ;
      } else if (operationKind == 2) {
        //uploading note file

        final task = _notesBucketRef.child(iD).child('NoteFile').putFile(file);
        task.snapshotEvents.listen((event) async {
          if (event.state == TaskState.canceled ||
              event.state == TaskState.error ||
              event.state == TaskState.paused) status = false;
          if (event.state == TaskState.running) {
            ScaffoldMessenger.of(context).removeCurrentSnackBar();
            ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                content: Text(
                    '${event.bytesTransferred / await file.length()} % completed')));
          }
        });
        final value = await task.whenComplete(() => null);
        if (value.state == TaskState.success && status) {
          res = await _notesBucketRef
              .child(iD)
              .child('NoteFile')
              .getDownloadURL();
        }
        ;
      }
    } on Exception catch (e) {
      print(e);
      return res;
    }
    return res;
  }

  static Future<FilePickerResult?> pickAPhoto() async {
    FilePickerResult? result =
        await FilePicker.platform.pickFiles(type: FileType.image);

    return result;
  }

  static Future<FilePickerResult?> pickANoteFile() async {
    FilePickerResult? result = await FilePicker.platform.pickFiles(
      type: FileType.custom,
      allowedExtensions: ['pdf', 'docx'],
    );

    return result;
  }
}
