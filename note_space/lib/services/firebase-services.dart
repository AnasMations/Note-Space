import 'dart:io';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:file_picker/file_picker.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter/cupertino.dart';
import '../models/note_model.dart';
import '../models/user_model.dart';

class FirestoreServices {
  //attributes
  static final _usersCollection =
      FirebaseFirestore.instance.collection('users');
  static final _notesCollection =
      FirebaseFirestore.instance.collection('notes');
  static final _categoriesCollection =
      FirebaseFirestore.instance.collection('categories');

//**********************     users             ********************** */

//creates a user , or if the user already exists, update their information
//parameters : user : a user that you create after succesfully collecting the data you need in the update profile screen
  static Future createUser(User user) async {
    //this generates a new empty doc in users collection and gives it the user id to set as the document id
    final newUserDoc = _usersCollection.doc(user.uID); //this is a doc reference
    await newUserDoc.set(user.toFirestore());
  }

  static Future updateUser(User user) async {
    //this generates a new empty doc in users collection and gives it the user id to set as the document id
    final newUserDoc = _usersCollection.doc(user.uID); //this is a doc reference
    await newUserDoc.set(user.toFirestore());
    //add check here somehow
  }

  //if this function finds the user your are looking for it returns it, else it will return null
  /*parameters :
  uID : this is the unique id generated by firebase auth once the user signs up for the first time
  you can fetch it anywhere in the project with 
  FirebaseAuth.instance.currentUser!.uid
  */
  static Future<User?> fetchUser(String uID) async {
    final userDoc =
        await _usersCollection.doc(uID).get(); //this is a doc snapshot
    if (userDoc.exists) {
      return User.fromFirestore(userDoc);
    } else {
      return null;
    }
  }

  //this function fetches multiples users from the database
  //by default all returend users are sorted based on their total rating
  //you choose how many users you want to fetch with the parameter 'number'
  //you can optionally also pass a second parameter 'lastUser'
  /*normally if you want an infinitely scrolling list (like a user leaderboard) where the application keeps
    fetching more users to display as we scroll down the list , you don't want the db to fetch every single user stored at once
    because this would be terrible for performace*/
  //instead if you pass the lastUser parameter, the db will start fetching users after that user
  //I.E lets say you fetched users 1 2 3 from the db
  //now you want to fetch more users but don't want to fetch 1 2 3 again
  //pass User number 3 as a paramter to this function and it will start fetching from user 4
  static Future<List<User>> fetchAllUsersByrating(int number,
      {User? lastUser}) async {
    final userDocs;
    List<User> userslist = [];
    if (lastUser != null) {
      final lastUserDoc = await _usersCollection.doc(lastUser.uID).get();
      if (lastUserDoc.exists) {
        userDocs = await _usersCollection
            .orderBy('totalRating', descending: true)
            .startAfterDocument(lastUserDoc)
            .limit(number)
            .get();
      } else {
        userDocs = await _usersCollection
            .orderBy('totalRating', descending: true)
            .limit(number)
            .get();
      }
    } else {
      userDocs = await _usersCollection
          .orderBy('totalRating', descending: true)
          .limit(number)
          .get();
    }
    for (final doc in userDocs.docs) {
      userslist.add(User.fromFirestore(doc));
    }
    return userslist;
  }

  //******************************************************************* */

  //**********************        notes ******************************** */
  //get
  static String generateNoteUID() {
    final newNoteDoc = _notesCollection.doc();
    return newNoteDoc.id;
  }

  static Future createNote(Note note) async {
    final newNoteDoc = _notesCollection.doc(note.uID);
    await newNoteDoc.set(note.toFirestore());
  }

  //updates an existing note , we don't check if this note already exists because how on earth would the user
  //trigger a note editing screen without first selecting an existing note
  static Future updateExistingNote(Note note) async {
    final noteDoc = _notesCollection.doc(note.uID);
    await noteDoc.set(note.toFirestore());
  }

  //fetches a note by its uID , if the note doesn't exist , returns null
  static Future<Note?> fetchNote(String? noteUID) async {
    final noteDoc =
        await _notesCollection.doc(noteUID).get(); //this is a doc snapshot
    if (noteDoc.exists) {
      return Note.fromFirestore(noteDoc);
    } else {
      return null;
    }
  }
}

class StorageServices {
  //attributes

  static final _usersBucketRef = FirebaseStorage.instance.ref().child('users');
  static final _notesBucketRef = FirebaseStorage.instance.ref().child('notes');

  //upload a file , if its a user photo then pass userUID , if its a note file or note cover pass the note id
  static Future<String?> uploadToStorage(
      String iD, FilePickerResult? result, int operationKind) async {
    if (result == null) return null;
    File file = File(result.files.first.path!);

    //upload file
    if (operationKind == 0) {
      //uploading user cover photo
      UploadTask task =
          _usersBucketRef.child(iD).child('ProfilePic').putFile(file);
      final completionResult = await task.whenComplete(() => null);
      if (completionResult.state == TaskState.success) {
        return await _usersBucketRef
            .child(iD)
            .child('ProfilePic')
            .getDownloadURL();
      } else {
        return null;
      }
    } else if (operationKind == 1) {
      //uploading note cover
      UploadTask task =
          _notesBucketRef.child(iD).child('NotePic').putFile(file);
      final completionResult = await task.whenComplete(() => null);
      if (completionResult.state == TaskState.success) {
        return await _notesBucketRef
            .child(iD)
            .child('NotePic')
            .getDownloadURL();
      } else {
        return null;
      }
    } else if (operationKind == 2) {
      //uploading note file
      UploadTask task =
          _notesBucketRef.child(iD).child('NoteFile').putFile(file);
      final completionResult = await task.whenComplete(() => null);
      if (completionResult.state == TaskState.success) {
        return await _notesBucketRef
            .child(iD)
            .child('NoteFile')
            .getDownloadURL();
      } else {
        return null;
      }
    }
  }

  static Future<FilePickerResult?> pickAPhoto() async {
    FilePickerResult? result =
        await FilePicker.platform.pickFiles(type: FileType.image);

    return result;
  }

  static Future<FilePickerResult?> pickANoteFile() async {
    FilePickerResult? result = await FilePicker.platform.pickFiles(
      type: FileType.custom,
      allowedExtensions: ['pdf', 'docx'],
    );

    return result;
  }
}
